// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3930.whoCares.subsystems;

import com.kauailabs.navx.frc.AHRS;
import org.usfirst.frc3930.whoCares.Robot;
import org.usfirst.frc3930.whoCares.RobotMap;
import org.usfirst.frc3930.whoCares.commands.*;
import com.ctre.CANTalon;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class driveBase extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	private int knifeValue = 1;
	AHRS ahrs;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon frontLeft = RobotMap.driveBasefrontLeft;
    private final CANTalon backLeft = RobotMap.driveBasebackLeft;
    private final CANTalon frontRight = RobotMap.driveBasefrontRight;
    private final CANTalon backRight = RobotMap.driveBasebackRight;
    private final RobotDrive robotDrive = RobotMap.driveBaseRobotDrive;
    private final PowerDistributionPanel pdp=new PowerDistributionPanel();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new drive());
        try {

            ahrs = new AHRS(SPI.Port.kMXP);
        } catch (RuntimeException ex ) {
            DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
        }

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public RobotDrive getRobotDrive(){
    	return robotDrive;
    }
    
    public void knife(){
    	if (knifeValue == 1) {
			knifeValue = 2;
		}
    	else{
    		knifeValue = 1;
    	}
    	
    }
    
    public int getKnifeValue(){
    	return knifeValue;
    }
    
    public void driveForward(){
    	frontLeft.setEncPosition(0);
    	frontRight.setEncPosition(0);
    	backLeft.setEncPosition(0);
    	backRight.setEncPosition(0);

    	robotDrive.arcadeDrive(-0.6, 0);
    	
    	
    }
    
    public void driveForward2(){
    	frontLeft.setEncPosition(0);
    	frontRight.setEncPosition(0);
    	backLeft.setEncPosition(0);
    	backRight.setEncPosition(0);

    	robotDrive.tankDrive(-0.5, -0.7);
    	
    	
    }

    
    public void driveForward3(){
    	frontLeft.setEncPosition(0);
    	frontRight.setEncPosition(0);
    	backLeft.setEncPosition(0);
    	backRight.setEncPosition(0);

    	robotDrive.tankDrive(-0.7, -0.5);
    	
    	
    }
    public void driveBward(){
    	frontLeft.setEncPosition(0);
    	frontRight.setEncPosition(0);
    	backLeft.setEncPosition(0);
    	backRight.setEncPosition(0);

    	robotDrive.arcadeDrive(0.4, 0);
    	
    	
    }
    
    
    public void strafeRightAlsoBackuup(){
    	frontLeft.setEncPosition(0);
    	frontRight.setEncPosition(0);
    	backLeft.setEncPosition(0);
    	backRight.setEncPosition(0);
    	
    	robotDrive.mecanumDrive_Cartesian(-0.5, 0, 0, ahrs.getRawAccelY());
    }

    public void strafeRightAndBackdown(){
    	backLeft.setEncPosition(0);
    	backRight.setEncPosition(0);
    	frontLeft.setEncPosition(0);
    	frontRight.setEncPosition(0);
    	
    	robotDrive.mecanumDrive_Cartesian(0.5, 0, 0, ahrs.getRawAccelY());
    }
    
    public void spin(){
    	
    	robotDrive.arcadeDrive(0.6,1);
    }
    
    public void drive(){
    	
    	
    //	System.out.println(knifeValue);
    	Robot.driveBase.getRobotDrive().mecanumDrive_Cartesian((Robot.oi.playerOne.getRawAxis(3)-Robot.oi.playerOne.getRawAxis(2))/knifeValue, Robot.oi.getplayerOne().getX()/knifeValue, Robot.oi.getplayerOne().getY()/knifeValue, ahrs.getRawAccelX());
    	//SmartDashboard.putNumber(   "RawGyro_Y",            ahrs.getRawAccelY());

    	/*
    	SmartDashboard.putNumber(   "FrontLeft",            frontLeft.getEncPosition());
    	SmartDashboard.putNumber(   "FrontRight",            frontRight.getEncPosition());
    	SmartDashboard.putNumber(   "BackLeft",            backLeft.getEncPosition());
    	SmartDashboard.putNumber(   "backRight",            backRight.getEncPosition());
    	*/

    	SmartDashboard.putNumber(   "Current 14",            pdp.getCurrent(14));
    	SmartDashboard.putNumber(   "Current 1",            pdp.getCurrent(1));
    	SmartDashboard.putNumber(   "Current 2",            pdp.getCurrent(2));
    	SmartDashboard.putNumber(   "Current 15",            pdp.getCurrent(15));
    }
}

